sketchy
=======

A demo of locality-sensitive hashing in Python.

Say again?
----------

You know how normal hashes are designed to _avoid_ collisions? Locality-sensitive hashes are designed to _cause_ collisions. In fact, the more similar the input data is, the more similar the resulting hashes will be, with a small and predictable error rate.

This makes them a useful tool for large scale data mining, as a component in:

* fuzzy-matching database records or similar documents
* nearest-neighbours clustering and classification
* duplicate detection
* content recommendation

et cetera.

You can choose the hash size in bits, and this lets you trade off space and time costs against accuracy and granularity.

It's not hugely optimized, but is designed to scale easily over Hadoop -- it targets Python 2.5 for Jython compatibility, and uses no extra libraries.

How does it work?
-----------------

This particular variant of LSH uses _sketches_, which are rough lower-dimensional representations of a point in higher-dimensional space.

It works by slicing up the space with a number of surfaces (hyperplanes), and seeing which side of each hyperplane the data point is on. This can be represented with just one bit per hyperplane. The reasoning is, genuinely similar items will be on the same side of most hyperplanes. The resulting hashes make up a Hamming code, i.e. the more bits two hashes have in common, the more similar their input data was.

The input for each item is a vector of numbers, which are understood as co-ordinates in the high-dimensional space. If you have fields of another kind, e.g. text or categories, you must map them into numeric form first, e.g. with a database or dictionary lookup.

**Important:** Don't leave things like numeric IDs in your data, as user 3318 isn't "similar to" user 3319, but the algorithm doesn't know that. The usual approach is to give each user a whole row or column, with a 0/1 flag or a count in each cell, e.g. in a users-vs-movies matrix for recommenders.

The original method is described here:

http://www.cs.princeton.edu/courses/archive/spr04/cos598B/bib/CharikarEstim.pdf

These pages were also useful when I was implementing it:

http://metaoptimize.com/qa/questions/8930/basic-questions-about-locally-sensitive-hashinglsh

http://www.coolsnap.net/kevin/?p=23

How do I use it?
----------------

See the source for a demo. In fact, most of the file is demo. The nuts-and-bolts are only a handful of lines of code.

License
-------

Do what thou wilt.

